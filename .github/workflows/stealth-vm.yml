name: Stealth VM (RDP + Auto-Heal)

on:
  workflow_dispatch:
  schedule:
    - cron: '0 */5 * * *'  # Auto-Heal every 5 hours

jobs:
  virtual-machine:
    runs-on: windows-latest
    timeout-minutes: 350
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4

    # 1. Setup Environment & Tools
    - name: Install Essentials
      run: |
        choco install rclone -y
        pip install py7zr
        
    # 2. "Resurrection" - Pull State from Cloud
    - name: Restore Soul (State)
      env:
        RCLONE_CONFIG_PASS: ${{ secrets.RCLONE_CONFIG_PASS }}
        RCLONE_CONFIG_BLOB: ${{ secrets.RCLONE_CONFIG_BLOB }}
      run: |
        # Configure rclone from secret blob
        if ($env:RCLONE_CONFIG_BLOB) {
            $env:RCLONE_CONFIG_BLOB | Out-File -Encoding UTF8 rclone.conf
        }
        mkdir C:\EnterpriseState -ErrorAction SilentlyContinue
        
        # Download state.zip (e.g. from TeraBox/GDrive alias 'remote')
        if (Test-Path rclone.conf) {
            rclone copy remote:backups/state.zip . --config rclone.conf --ignore-errors
        }
        
        # Unzip if exists
        if (Test-Path state.zip) {
          7z x state.zip -oC:\EnterpriseState
        } else {
          Write-Host "New Life Started."
        }

    # 3. Enable RDP & Ngrok Tunnel (Debug Mode + Shim Fix)
    - name: Start Ngrok Tunnel
      env:
        NGROK_AUTH_TOKEN: ${{ secrets.NGROK_AUTH_TOKEN }}
      run: |
        choco install ngrok -y
        
        if (-not $env:NGROK_AUTH_TOKEN) {
            Write-Host "::error title=Missing Secret::NGROK_AUTH_TOKEN is missing! Add it in Settings > Secrets."
            exit 1
        }
        
        # 1. Bruteforce Find Real Ngrok (Bypass Choco Shim)
        # Shims exit immediately, causing "Process DIED" errors. We need the real binary.
        $ngrokPath = Get-ChildItem "C:\ProgramData\chocolatey\lib\ngrok\tools\ngrok*.exe" -Recurse -ErrorAction SilentlyContinue | Select-Object -ExpandProperty FullName -First 1
        
        if (-not $ngrokPath) {
             # Fallback to standard path if lib search fails
             $ngrokPath = (Get-Command ngrok -ErrorAction SilentlyContinue).Source
        }
        
        Write-Host "::notice title=Ngrok Path::Targeting Real Binary: $ngrokPath"
        
        if (-not $ngrokPath -or -not (Test-Path $ngrokPath)) {
             Write-Host "::error title=Ngrok Not Found::Could not find ngrok.exe in standard paths."
             exit 1
        }

        # 2. Authenticate
        & $ngrokPath authtoken $env:NGROK_AUTH_TOKEN
        
        # 3. Start Process with Explicit Log Output
        $logPath = Join-Path $pwd "ngrok.log"
        $errPath = Join-Path $pwd "ngrok_error.log"
        
        Write-Host "Starting Ngrok..."
        $p = Start-Process -FilePath $ngrokPath -ArgumentList "tcp 3389 --log=stdout" -PassThru -RedirectStandardOutput $logPath -RedirectStandardError $errPath -WindowStyle Hidden
        
        # 4. Wait for Tunnel (Loop with Debug Checks)
        $url = $null
        for ($i = 0; $i -lt 30; $i++) {
            Start-Sleep -Seconds 2
            
            # Check if process died
            if ($p.HasExited) {
                Write-Host "::error title=Ngrok Crashed::Process exited unexpectedly."
                
                if (Test-Path $logPath) { 
                    $logContent = Get-Content $logPath | Out-String
                    Write-Host "::error title=Ngrok STDOUT::$logContent"
                }
                if (Test-Path $errPath) { 
                    $errContent = Get-Content $errPath | Out-String
                    Write-Host "::error title=Ngrok STDERR::$errContent"
                }
                exit 1
            }

            # Check API for Tunnel URL
            try {
                $json = Invoke-RestMethod http://localhost:4040/api/tunnels -ErrorAction SilentlyContinue
                $url = $json.tunnels[0].public_url
                if ($url) { break }
            } catch {
                Write-Host "Waiting for API... ($i/30)"
            }
        }

        if (-not $url) {
            Write-Host "::error title=Timeout::Could not get RDP address from Ngrok API."
            exit 1
        }

        # SUCCESS: Print to Summary Page
        Write-Host "::notice title=RDP SUCCESS::Address: $url"
        $url | Out-File RDP_CONNECTION.txt

    - name: Enable Windows RDP
      run: |
        Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -name "fDenyTSConnections" -value 0
        Enable-NetFirewallRule -DisplayGroup "Remote Desktop"
        Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -name "UserAuthentication" -value 1
        net user runneradmin "${{ secrets.VM_PASSWORD }}" /add
        net localgroup administrators runneradmin /add

    # 4. Always Upload Logs (For Debugging)
    - name: Upload Debug Logs
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: debug-logs
        path: |
          *.log
          RDP_CONNECTION.txt

    # 5. Keep Alive & Auto-Heal Sync Loop
    - name: Run & Sync Loop
      run: |
        $counter = 0
        while ($true) {
          Start-Sleep -Seconds 1800 # Sync every 30 mins
          
          # "Save Soul" - Push State to Cloud
          if (Test-Path rclone.conf) {
             7z a state.zip C:\EnterpriseState\*
             rclone copy state.zip remote:backups/ --config rclone.conf --ignore-errors
             Write-Host "Auto-Heal Checkpoint $counter Saved."
          } else {
             Write-Host "No Cloud Config - Running Ephemeral Mode"
          }
          $counter++
        }
